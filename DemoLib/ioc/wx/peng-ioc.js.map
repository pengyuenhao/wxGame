{"version":3,"file":"peng-ioc.js","sources":["webpack://ioc/webpack/bootstrap","webpack://ioc/./src/Bind/BindConst.ts","webpack://ioc/./src/Bind/Binder.ts","webpack://ioc/./src/Bind/Binding.ts","webpack://ioc/./src/Command/Command.ts","webpack://ioc/./src/Command/CommandBinder.ts","webpack://ioc/./src/Command/CommandBinding.ts","webpack://ioc/./src/Command/CommandConst.ts","webpack://ioc/./src/Command/ICommandBinder.ts","webpack://ioc/./src/Context/Context.ts","webpack://ioc/./src/Context/IRoot.ts","webpack://ioc/./src/Decorator/DecoratorClass.ts","webpack://ioc/./src/Decorator/DecoratorClassBinder.ts","webpack://ioc/./src/Decorator/DecoratorClassBinding.ts","webpack://ioc/./src/Decorator/DecoratorConst.ts","webpack://ioc/./src/Injector/InjectBinder.ts","webpack://ioc/./src/Injector/InjectBinding.ts","webpack://ioc/./src/Injector/InjectDecorator.ts","webpack://ioc/./src/Injector/InjectFactory.ts","webpack://ioc/./src/Injector/Injector.ts","webpack://ioc/./src/IocConst.ts","webpack://ioc/./src/Pool.ts","webpack://ioc/./src/Prototype.ts","webpack://ioc/./src/Signal/Signal.ts","webpack://ioc/./src/Signal/SignalManager.ts","webpack://ioc/./src/Stack.ts","webpack://ioc/./src/index.ts"],"sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = \"./src/index.ts\");\n","export var BindingConst;\n\n(function (BindingConst) {\n  BindingConst.NULL = Symbol.for(\"NULL\").toString();\n})(BindingConst || (BindingConst = {}));","import { Binding } from \"./Binding\";\nimport { BindingConst } from \"./BindConst\";\nexport class Binder {\n  constructor() {\n    this.init();\n  }\n\n  init() {\n    this._bindings = new Map();\n  }\n\n  resolver(binding) {\n    let key = binding.key;\n    this.resolveBinding(binding, key);\n  }\n\n  resolveBinding(binding, key) {\n    let bindingName = binding.name == null ? BindingConst.NULL : binding.name;\n    let dict;\n\n    if (this._bindings.has(key)) {\n      dict = this._bindings.get(key);\n\n      if (dict.has(bindingName)) {\n        let existingBinding = dict.get(bindingName);\n\n        if (existingBinding != binding) {\n          if (!existingBinding.value) {\n            dict.delete(bindingName);\n          }\n        }\n      }\n    } else {\n      dict = new Map();\n\n      this._bindings.set(key, dict);\n    }\n\n    if (dict.has(BindingConst.NULL) && dict.get(BindingConst.NULL) === binding) {\n      dict.delete(BindingConst.NULL);\n    }\n\n    if (!dict.has(bindingName)) {\n      dict.set(bindingName, binding);\n    }\n  }\n\n  bind(key) {\n    let binding = this.getRawBinding();\n    binding.bind(key);\n    return binding;\n  }\n\n  unbind(key, name) {\n    let checkKey = Binding.checkAbstract(key);\n\n    if (this._bindings.has(checkKey)) {\n      let dict = this._bindings.get(checkKey);\n\n      let bindingName;\n\n      if (name) {\n        bindingName = name;\n      } else {\n        bindingName = BindingConst.NULL;\n      }\n\n      if (dict.has(bindingName)) {\n        dict.delete(bindingName);\n      }\n    }\n  }\n\n  getRawBinding() {\n    return new Binding(this.resolver.bind(this));\n  }\n\n  getBinding(key, name) {\n    if (this._bindings.has(key)) {\n      let dict = this._bindings.get(key);\n\n      if (!name) {\n        name = BindingConst.NULL;\n      }\n\n      if (dict.has(name)) {\n        return dict.get(name);\n      } else {\n        return null;\n      }\n    }\n  }\n\n  getBindingMap(key) {\n    if (this._bindings.has(key)) {\n      return this._bindings.get(key);\n    }\n  }\n\n}\nexport class NBinder {\n  get constructorName() {\n    return \"IBinder\";\n  }\n\n}","export class NBinding {\n  get constructorName() {\n    return \"IBinding\";\n  }\n\n}\nexport class Binding {\n  get key() {\n    return this._key;\n  }\n\n  get value() {\n    return this._value;\n  }\n\n  get name() {\n    return this._name;\n  }\n\n  constructor(resolver) {\n    this._resolver = resolver;\n    this._key = null;\n    this._value = null;\n    this._name = null;\n  }\n\n  bind(key) {\n    this._key = Binding.checkAbstract(key);\n    return this;\n  }\n\n  to(value) {\n    this._value = value;\n    if (this._resolver != null) this._resolver(this);\n    return this;\n  }\n\n  toName(name) {\n    this._name = name;\n    if (this._resolver != null) this._resolver(this);\n    return this;\n  }\n\n  get isKeyConstructor() {\n    return Binding.isConstructor(this._key);\n  }\n\n  get isValueConstructor() {\n    return Binding.isConstructor(this._value);\n  }\n\n  static isConstructor(value) {\n    if (typeof value !== \"function\") {\n      return false;\n    }\n\n    if (!value.prototype) {\n      return false;\n    }\n\n    return true;\n  }\n\n  static checkAbstract(key) {\n    let constructorName;\n    let prototype = key.prototype;\n\n    if (prototype !== null && prototype !== undefined && prototype.constructorName !== null && prototype.constructorName !== undefined) {\n      constructorName = prototype.constructorName;\n    } else {\n      constructorName = key;\n    }\n\n    return constructorName;\n  }\n\n}","var __decorate = this && this.__decorate || function (decorators, target, key, desc) {\n  var c = arguments.length,\n      r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,\n      d;\n  if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n  return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\n\nimport { NCommandBinder } from \"./ICommandBinder\";\nimport { NInjectBinder } from \"../Injector/InjectBinder\";\nimport { inject } from \"../Injector/InjectDecorator\";\nexport class NCommand {\n  get constructorName() {\n    return \"ICommand\";\n  }\n\n}\nexport class Command {\n  constructor() {\n    this.sequenceId = null;\n    this.data = null;\n    this.args = null;\n    this._clean = false;\n    this._retain = false;\n  }\n\n  deploy() {\n    this._clean = false;\n  }\n\n  clean() {\n    this._clean = true;\n  }\n\n  get isClean() {\n    return this._clean;\n  }\n\n  retain() {\n    this._retain = true;\n  }\n\n  release() {\n    this._retain = false;\n  }\n\n  get isRetain() {\n    return this._retain;\n  }\n\n  restore() {\n    this.injectBinder.getInjector().uninject(this);\n    this.clean();\n  }\n\n  execute(...args) {\n    return null;\n  }\n\n}\n\n__decorate([inject(NInjectBinder)], Command.prototype, \"injectBinder\", void 0);\n\n__decorate([inject(NCommandBinder)], Command.prototype, \"commandBinder\", void 0);","var __decorate = this && this.__decorate || function (decorators, target, key, desc) {\n  var c = arguments.length,\n      r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,\n      d;\n  if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n  return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\n\nimport { Binding } from \"../Bind/Binding\";\nimport { NInjectBinder } from \"../Injector/InjectBinder\";\nimport { CommandBinding } from \"./CommandBinding\";\nimport { Signal } from \"../Signal/Signal\";\nimport { NCommand } from \"./Command\";\nimport { Pool } from \"../Pool\";\nimport { CommandConst } from \"./CommandConst\";\nimport { inject } from \"../Injector/InjectDecorator\";\nimport { Binder } from \"../Bind/Binder\";\nimport { NSignalManager } from \"../Signal/SignalManager\";\nexport class CommandBinder extends Binder {\n  constructor() {\n    super(...arguments);\n    this.pools = new Map();\n    this.activeCommands = new Set();\n    this.activeSequences = new Map();\n    this.usePooling = false;\n  }\n\n  getPool(type) {\n    if (this.pools.has(type)) return this.pools.get(type);\n    return null;\n  }\n\n  resolver(binding) {\n    super.resolver(binding);\n\n    if (this.usePooling && binding.isPooled) {\n      if (binding.value != null) {\n        let that = this;\n        let values = binding.value;\n\n        if (values.length === 0) {\n          values = [];\n          values.push(binding.value);\n        }\n\n        if (values && values.length > 0) {\n          values.forEach(value => {\n            if (that.pools.has(value) == false) {\n              let myPool = this.makePoolFromType(value);\n              that.pools.set(value, myPool);\n            }\n          });\n        }\n      }\n    }\n  }\n\n  makePoolFromType(type) {\n    let poolType = type;\n    this.injectBinder.bind(type).to(type);\n    this.injectBinder.bind(Pool).to(Pool).toName(CommandConst.COMMAND_POOL);\n    let pool = this.injectBinder.getInstance(Pool, CommandConst.COMMAND_POOL);\n    this.injectBinder.unbind(Pool, CommandConst.COMMAND_POOL);\n    pool.bind(poolType);\n    return pool;\n  }\n\n  getRawBinding() {\n    return new CommandBinding(this.resolver.bind(this));\n  }\n\n  bind(key) {\n    return super.bind(key);\n  }\n\n  invokeCommand(cmd, binding, args, depth) {\n    let command = this.createCommand(cmd, args);\n    command.sequenceId = depth;\n    this.trackCommand(command, binding);\n    command.return = this.executeCommand(command, args);\n    return command;\n  }\n\n  createCommand(cmd, data) {\n    let command = this.getCommand(cmd);\n\n    if (command == null) {\n      let msg = \"A Command \";\n\n      if (data != null) {\n        msg += \"tied to data \" + data.toString();\n      }\n\n      msg += \" could not be instantiated.\\nThis might be caused by a null pointer during instantiation or failing to override Execute (generally you shouldn't have constructor code in Commands).\";\n      throw new Error(msg);\n    }\n\n    command.data = data;\n    return command;\n  }\n\n  getCommand(type) {\n    if (this.usePooling && this.pools.has(type)) {\n      let pool = this.pools.get(type);\n      let command = pool.getInstance();\n\n      if (command) {\n        if (command.isClean) {\n          this.injectBinder.getInjector().inject(command);\n          command.deploy();\n        }\n      } else {\n        command = this.injectBinder.getInstance(type, null);\n        pool.add(command);\n      }\n\n      return command;\n    } else {\n      this.injectBinder.bind(NCommand).to(type);\n      let command = this.injectBinder.getInstance(NCommand, null);\n      this.injectBinder.unbind(NCommand, null);\n      return command;\n    }\n  }\n\n  trackCommand(command, binding) {\n    if (binding.isSequence) {\n      this.activeSequences.set(command, binding);\n    } else {\n      this.activeCommands.add(command);\n    }\n  }\n\n  executeCommand(command, args) {\n    if (command == null) {\n      return;\n    }\n\n    return command.execute(...args);\n  }\n\n  onDispose(trigger, ...args) {\n    let results = [];\n    let result;\n    let binding = this.getBinding(trigger, null);\n\n    if (binding != null) {\n      if (binding.isSequence) {\n        result = this.next(binding, args, 0);\n        if (result !== null) results.push(...result);\n      } else {\n        if (Array.isArray(binding.value)) {\n          for (let i = 0; i < binding.value.length; i++) {\n            result = this.next(binding, args, i);\n            if (result !== null) results.push(...result);\n          }\n        } else {\n          return this.next(binding, args, 0);\n        }\n      }\n    }\n\n    if (results.length > 0) return results;else return null;\n  }\n\n  next(binding, args, depth) {\n    let cmd;\n\n    if (Array.isArray(binding.value)) {\n      if (depth < binding.value.length) {\n        cmd = binding.value[depth];\n      }\n    } else {\n      if (depth === 0) {\n        cmd = binding.value;\n      }\n    }\n\n    let results = null;\n\n    if (cmd) {\n      let command = this.invokeCommand(cmd, binding, args, depth);\n      let ret = command.return;\n      let res;\n      command.return = null;\n\n      if (ret !== null) {\n        results = [];\n        results.push(ret);\n      }\n\n      res = this.releaseCommand(command);\n\n      if (res !== null) {\n        if (!results) results = [];\n        results.push(res);\n      }\n    } else {\n      this.disposeOfSequencedData(args);\n\n      if (binding.isOnce) {\n        this.unbind(binding, null);\n      }\n    }\n\n    return results;\n  }\n\n  disposeOfSequencedData(data) {}\n\n  releaseCommand(command) {\n    if (!command.isRetain) {\n      let t = command.constructor;\n\n      if (this.usePooling && this.pools.has(t)) {\n        this.pools.get(t).returnInstance(command);\n      }\n\n      if (this.activeCommands.has(command)) {\n        this.activeCommands.delete(command);\n      } else if (this.activeSequences.has(command)) {\n        let binding = this.activeSequences.get(command);\n        let data = command.data;\n        this.activeSequences.delete(command);\n        return this.next(binding, data, command.sequenceId + 1);\n      }\n    }\n\n    return null;\n  }\n\n}\n\n__decorate([inject(NInjectBinder)], CommandBinder.prototype, \"injectBinder\", void 0);\n\nexport class SignalCommandBinder extends CommandBinder {\n  constructor() {\n    super(...arguments);\n    this.onDisposeBind = this.onDispose.bind(this);\n    this.usePooling = true;\n  }\n\n  resolveBinding(binding, key) {\n    super.resolveBinding(binding, key);\n\n    if (this._bindings.has(key)) {\n      let signal = key;\n      signal.addListener(this.onDisposeBind);\n    }\n  }\n\n  bind(value) {\n    let signal = null;\n\n    if (Binding.isConstructor(value)) {\n      let binding = this.injectBinder.getBinding(value, null);\n\n      if (binding == null) {\n        binding = this.injectBinder.bind(value);\n        binding.toSingleton();\n      }\n\n      signal = this.injectBinder.getInstance(value, null);\n    } else {\n      if (value instanceof Signal) {\n        signal = value;\n      }\n    }\n\n    if (!signal) {\n      let sglMgr = this.injectBinder.getInstance(NSignalManager, null);\n      signal = sglMgr.get(value);\n    }\n\n    return super.bind(signal);\n  }\n\n  getBinding(key, name) {\n    let signal;\n\n    if (Binding.isConstructor(key)) {\n      signal = this.injectBinder.getInstance(key, name);\n    } else {\n      signal = key;\n    }\n\n    return super.getBinding(signal, name);\n  }\n\n  invokeCommand(cmd, binding, args, depth) {\n    let signal = binding.key;\n    let command = this.createCommandForSignal(cmd, args);\n    command.sequenceId = depth;\n    this.trackCommand(command, binding);\n    command.return = this.executeCommand(command, args);\n    return command;\n  }\n\n  createCommandForSignal(cmd, args) {\n    let that = this;\n\n    if (args != null) {\n      let signalData = args;\n      let injectedTypes = new Set();\n      let values = [signalData];\n    }\n\n    let command = that.getCommand(cmd);\n    command.data = args;\n    return command;\n  }\n\n}","import { Binding } from \"../Bind/Binding\";\nexport class CommandBinding extends Binding {\n  get isSequence() {\n    return this._isSequence;\n  }\n\n  get isOnce() {\n    return this._isOnce;\n  }\n\n  to(value) {\n    return super.to(value);\n  }\n\n  toName(name) {\n    return super.toName(name);\n  }\n\n  Pooled() {\n    this.isPooled = true;\n\n    this._resolver(this);\n\n    return this;\n  }\n\n}","export var CommandConst;\n\n(function (CommandConst) {\n  CommandConst[\"COMMAND_POOL\"] = \"COMMAND_POOL\";\n})(CommandConst || (CommandConst = {}));","export class NCommandBinder {\n  get constructorName() {\n    return \"ICommandBinder\";\n  }\n\n}","import { InjectBinder, NInjectBinder } from \"../Injector/InjectBinder\";\nimport { CommonEnum } from \"../IocConst\";\nimport { SignalCommandBinder } from \"../Command/CommandBinder\";\nimport { NCommandBinder } from \"../Command/ICommandBinder\";\nimport { NSignalManager, SignalManager } from \"../Signal/SignalManager\";\nexport class NContext {\n  get constructorName() {\n    return \"IContext\";\n  }\n\n}\nexport class Context {\n  get injectBinder() {\n    if (!this._injectBinder) {\n      this._injectBinder = new InjectBinder();\n    }\n\n    return this._injectBinder;\n  }\n\n  set crossContextBinder(value) {\n    this._crossContextBinder = value;\n  }\n\n  get crossContextBinder() {\n    return this._crossContextBinder;\n  }\n\n  get commandBinder() {\n    return this._commandBinder;\n  }\n\n  getRoot() {\n    return this.root;\n  }\n\n  constructor(root) {\n    if (Context.firstContext == null || Context.firstContext.getRoot() == null) {\n      Context.firstContext = this;\n      this.crossContextBinder = this.injectBinder;\n    } else {\n      Context.firstContext.addCrossContext(this);\n    }\n\n    this.setRoot(root);\n    this.addCore();\n    this.start();\n  }\n\n  getIns(key, name) {\n    return this.injectBinder.getInstance(key, name);\n  }\n\n  addCrossContext(context) {\n    context.crossContextBinder = this.injectBinder;\n    return this;\n  }\n\n  removeCrossContext(childContext) {}\n\n  setRoot(root) {\n    this.root = root;\n    return this;\n  }\n\n  restart() {\n    this.addCore();\n    this.start();\n    return this;\n  }\n\n  start() {\n    this.instantiateCore();\n    this.mapBindings();\n    this.postBindings();\n    this.launch();\n    return this;\n  }\n\n  launch() {\n    this.injectBinder.inject(this);\n    this.injectBinder.inject(this.root);\n  }\n\n  instantiateCore() {\n    this._commandBinder = this.injectBinder.getInstance(NCommandBinder, null);\n  }\n\n  mapBindings() {}\n\n  postBindings() {}\n\n  addCore() {\n    this.injectBinder.bind(NInjectBinder).toValue(this.injectBinder);\n    this.injectBinder.bind(NCommandBinder).to(SignalCommandBinder).toSingleton();\n    this.injectBinder.bind(NSignalManager).to(SignalManager).toSingleton();\n    this.injectBinder.bind(CommonEnum.Context).toValue(this);\n    this.injectBinder.bind(CommonEnum.Root).toValue(this.root);\n  }\n\n}","export class NRoot {\n  get constructorName() {\n    return \"IRoot\";\n  }\n\n}","export class DecoratorClass {\n  get list() {\n    return this._list;\n  }\n\n  set list(value) {\n    this._list = value;\n  }\n\n}","import { Binder } from \"../Bind/Binder\";\nimport { DecoratorClass } from \"./DecoratorClass\";\nimport { DecoratorClassBinding } from \"./DecoratorClassBinding\";\nimport { Prototype } from \"../Prototype\";\nimport { BindingConst } from \"../Bind/BindConst\";\nexport class DecoratorClassBinder extends Binder {\n  init() {\n    this._bindings = new Map();\n    this._decoratorClassBufferMap = new Map();\n  }\n\n  has(key) {\n    return this._bindings.has(key);\n  }\n\n  get(target) {\n    if (!(target instanceof Object)) throw new Error(\"proto must is a object but\" + target + \"is not\");\n    let ctor = target;\n\n    let injectClass = this._decoratorClassBufferMap.get(ctor);\n\n    if (!injectClass) {\n      let extendsList = Prototype.getPrototypeList(ctor);\n      extendsList.push(ctor);\n      injectClass = new DecoratorClass();\n      let list = [];\n      let dict;\n      let that = this;\n      let bindingMaps = [];\n\n      for (let i = 0; i < extendsList.length; i++) {\n        dict = that.getBindingMap(extendsList[i]);\n\n        if (dict && dict.size > 0) {\n          dict.forEach(function (inside) {\n            bindingMaps.push(inside);\n          });\n        }\n      }\n\n      let inside;\n\n      for (let i = 0; i < bindingMaps.length; i++) {\n        inside = bindingMaps[i];\n\n        if (inside && inside.size > 0) {\n          let values = inside.values();\n\n          for (let j = 0; j < inside.size; j++) {\n            let binding = values.next();\n            list.push(binding.value);\n          }\n        }\n      }\n\n      injectClass.list = list;\n\n      this._decoratorClassBufferMap.set(ctor, injectClass);\n    }\n\n    return injectClass;\n  }\n\n  bind(key) {\n    return super.bind(key);\n  }\n\n  getBinding(key, name) {\n    return super.getBinding(key, name);\n  }\n\n  getRawBinding() {\n    return new DecoratorClassBinding(this.resolver.bind(this));\n  }\n\n  resolver(binding) {\n    super.resolver(binding);\n  }\n\n  resolveBinding(binding, key) {\n    if (!binding.property) return;\n    let bindingName = binding.name == null ? BindingConst.NULL : binding.name;\n    let dict;\n\n    if (this._bindings.has(key)) {\n      dict = this._bindings.get(key);\n\n      if (dict.has(bindingName)) {\n        let insideDict = dict.get(bindingName);\n\n        if (insideDict.has(binding.property)) {\n          let existingBinding = insideDict.get(binding.property);\n\n          if (existingBinding) {\n            if (existingBinding != binding) {\n              if (!existingBinding.value) {\n                dict.delete(bindingName);\n              }\n            }\n          }\n        }\n      }\n    } else {\n      dict = new Map();\n\n      this._bindings.set(key, dict);\n    }\n\n    if (dict.has(BindingConst.NULL)) {\n      let insideDic = dict.get(BindingConst.NULL);\n\n      if (insideDic.has(binding.property)) {\n        let existingBinding = insideDic.get(binding.property);\n\n        if (binding.property === binding) {\n          insideDic.delete(BindingConst.NULL);\n        }\n      }\n    }\n\n    let insideDict;\n\n    if (!dict.has(bindingName)) {\n      insideDict = new Map();\n      insideDict.set(binding.property, binding);\n      dict.set(bindingName, insideDict);\n    } else {\n      insideDict = dict.get(bindingName);\n\n      if (!insideDict.has(binding.property)) {\n        insideDict.set(binding.property, binding);\n      }\n    }\n  }\n\n  getBindingMap(key) {\n    if (this._bindings.has(key)) {\n      return this._bindings.get(key);\n    }\n  }\n\n}","import { Binding } from \"../Bind/Binding\";\nexport class DecoratorClassBinding extends Binding {\n  get property() {\n    return this._property;\n  }\n\n  toProperty(property) {\n    this._property = property;\n    if (this._resolver != null) this._resolver(this);\n    return this;\n  }\n\n  to(value) {\n    return super.to(value);\n  }\n\n  toName(name) {\n    return super.toName(name);\n  }\n\n}","import { DecoratorClassBinder } from \"./DecoratorClassBinder\";\nexport var DecoratorConst;\n\n(function (DecoratorConst) {\n  DecoratorConst.DECORATOR_CLASS_BINDER = new DecoratorClassBinder();\n})(DecoratorConst || (DecoratorConst = {}));","import { DecoratorConst } from \"../Decorator/DecoratorConst\";\nimport { Binder } from \"../Bind/Binder\";\nimport { Injector } from \"./Injector\";\nimport { InjectBinding } from \"./InjectBinding\";\nimport { BindingConst } from \"../Bind/BindConst\";\nimport { Binding } from \"../Bind/Binding\";\nconst ClassBinder = DecoratorConst.DECORATOR_CLASS_BINDER;\nexport class NInjectBinder {\n  get constructorName() {\n    return \"IInjectBinder\";\n  }\n\n}\nexport class InjectBinder extends Binder {\n  init() {\n    super.init();\n    this._injector = new Injector();\n    this._injector.binder = this;\n    this._injector.injectClassBinder = ClassBinder;\n  }\n\n  getInjector() {\n    return this._injector;\n  }\n\n  getInstance(key, name) {\n    if (!name) name = BindingConst.NULL;\n    let binding = this.getBinding(Binding.checkAbstract(key), name);\n\n    if (binding == null) {\n      throw new Error(\"InjectionBinder has no binding for:\\n\\tkey: \" + key + \"\\nname: \" + name);\n    }\n\n    let instance = this._injector.instantiate(binding, false);\n\n    this._injector.tryInject(binding, instance);\n\n    return instance;\n  }\n\n  inject(target, userClass) {\n    this.getInjector().inject(target, userClass);\n  }\n\n  getBinding(key, name) {\n    return super.getBinding(key, name);\n  }\n\n  bind(key) {\n    return super.bind(key);\n  }\n\n  getRawBinding() {\n    return new InjectBinding(this.resolver.bind(this));\n  }\n\n  unbindAllMark() {\n    let that = this;\n    let unbinds = [];\n\n    this._bindings.forEach(dict => {\n      dict.forEach(binding => {\n        if (binding.isUnbind()) {\n          unbinds.push(binding);\n        }\n      });\n    });\n\n    unbinds.forEach(binding => {\n      that.unbind(binding.key, binding.name);\n    });\n  }\n\n}","import { Binding } from \"../Bind/Binding\";\nexport class InjectBinding extends Binding {\n  constructor() {\n    super(...arguments);\n    this._isUnbind = false;\n    this._bindingType = \"Default\";\n    this._isInject = true;\n  }\n\n  isInject() {\n    return this._isInject;\n  }\n\n  getArgs() {\n    return this._args;\n  }\n\n  getBindingType() {\n    return this._bindingType;\n  }\n\n  isUnbind() {\n    return this._isUnbind;\n  }\n\n  toArgs() {\n    this._args = arguments;\n\n    if (this._resolver != null) {\n      this._resolver(this);\n    }\n\n    return this;\n  }\n\n  toSingleton() {\n    if (this._bindingType === \"Value\") {\n      return this;\n    }\n\n    this._bindingType = \"Singleton\";\n\n    if (this._resolver != null) {\n      this._resolver(this);\n    }\n\n    return this;\n  }\n\n  unBind() {\n    this._isUnbind = true;\n    return this;\n  }\n\n  toValue(value) {\n    this._bindingType = \"Value\";\n    this.setValue(value);\n    return this;\n  }\n\n  setValue(o) {\n    this.to(o);\n    return this;\n  }\n\n  toInject(value) {\n    this._isInject = value;\n    return this;\n  }\n\n  to(value) {\n    return super.to(value);\n  }\n\n  toName(name) {\n    return super.toName(name);\n  }\n\n}","import { DecoratorConst } from \"../Decorator/DecoratorConst\";\nimport { Binding } from \"../Bind/Binding\";\nconst ClassBinder = DecoratorConst.DECORATOR_CLASS_BINDER;\nexport function inject() {\n  switch (arguments.length) {\n    case 0:\n      break;\n\n    case 1:\n      return injectNoNameFunc(arguments[0]);\n      break;\n\n    case 2:\n      return injectToNameFunc(arguments[0], arguments[1]);\n      break;\n\n    case 3:\n      break;\n  }\n}\n\nconst injectNoNameFunc = _constructor => {\n  return function (_target, _property) {\n    injectFunc(_target, _constructor, _property);\n  };\n};\n\nconst injectToNameFunc = (_constructor, _name) => {\n  return function (_target, _property) {\n    injectFunc(_target, _constructor, _property, _name);\n  };\n};\n\nfunction injectFunc(_target, _constructor, _property, _name) {\n  ClassBinder.bind(_target.constructor).to(Binding.checkAbstract(_constructor)).toProperty(_property).toName(_name);\n}","import { Binding } from \"../Bind/Binding\";\nexport class InjectFactory {\n  constructor() {}\n\n  get(binding, args) {\n    if (binding == null) {\n      throw new Error(\"InjectorFactory cannot act on null binding\");\n    }\n\n    let bindingType = binding.getBindingType();\n\n    switch (bindingType) {\n      case \"Singleton\":\n        return this.singletonOf(binding, args);\n        break;\n\n      case \"Value\":\n        return this.getValueOf(binding);\n        break;\n\n      default:\n        break;\n    }\n\n    return this.instanceOf(binding, args);\n  }\n\n  instanceOf(binding, args) {\n    if (binding.value != null) {\n      return this.createFromValue(binding.value, args);\n    }\n\n    let value = this.generateImplicit(binding.key, args);\n    return this.createFromValue(value, args);\n  }\n\n  createFromValue(c, args) {\n    let instance = null;\n\n    try {\n      if (args == null || args.length == 0) {\n        instance = new c();\n      } else {\n        instance = new c(args);\n      }\n    } catch (_a) {}\n\n    return instance;\n  }\n\n  generateImplicit(key, args) {\n    if (!key) return null;\n\n    if (Binding.isConstructor(key)) {\n      return this.createFromValue(key, args);\n    }\n\n    throw new Error(\"InjectorFactory can't instantiate an Interface or Abstract Class. Class: \" + key.ToString());\n  }\n\n  singletonOf(binding, args) {\n    if (binding.value != null) {\n      let o = this.createFromValue(binding.value, args);\n      if (o == null) return null;\n      binding.setValue(o);\n    } else {\n      binding.setValue(this.generateImplicit(binding.key, args));\n    }\n\n    return binding.value;\n  }\n\n  getValueOf(binding) {\n    return binding.value;\n  }\n\n}","import { InjectFactory } from \"./InjectFactory\";\nexport class Injector {\n  constructor() {\n    this.factory = null;\n    this.binder = null;\n    this.injectClassBinder = null;\n    this.factory = new InjectFactory();\n  }\n\n  uninject(target, userClass) {\n    if (!this.binder || !target) throw new Error(\"Attempt to inject into Injector without a Binder or null instance\");\n    let type = typeof target;\n\n    if (type === \"string\" || type === \"boolean\" || type === \"number\" || type === \"symbol\" || type === \"undefined\" || type === \"function\") {\n      return target;\n    }\n\n    if (!userClass) {\n      userClass = target.constructor;\n    }\n\n    let injectClass = this.injectClassBinder.get(userClass);\n    this.decoratorUnInject(target, injectClass);\n  }\n\n  decoratorUnInject(target, injectClass) {\n    let that = this;\n    injectClass.list.forEach(binding => {\n      let injectBinding = that.binder.getBinding(binding.value, binding.name);\n\n      if (injectBinding) {\n        target[binding.property] = null;\n      }\n    });\n  }\n\n  instantiate(binding, tryInjectHere) {\n    if (!this.binder || !this.factory) throw new Error(\"Attempt to instantiate from Injector without a Binder or inject into Injector without a Factory\");\n    let constructor = null;\n    let instance = null;\n\n    if (binding.isValueConstructor) {\n      constructor = binding.value;\n    } else {\n      instance = binding.value;\n    }\n\n    if (!constructor && binding.isKeyConstructor) {\n      constructor = binding.key;\n    }\n\n    if (!instance && constructor) {\n      let args = binding.getArgs();\n      instance = this.factory.get(binding, args);\n\n      if (tryInjectHere) {\n        this.tryInject(binding, instance);\n      }\n    }\n\n    return instance;\n  }\n\n  tryInject(binding, target) {\n    if (target != null) {\n      if (binding.isInject()) {\n        target = this.inject(target);\n      }\n\n      if (binding.getBindingType() == \"Singleton\" || binding.getBindingType() == \"Value\") {\n        binding.toInject(false);\n      }\n    }\n\n    return target;\n  }\n\n  inject(target, userClass) {\n    if (!this.binder || !target) throw new Error(\"Attempt to inject into Injector without a Binder or null instance\");\n    let type = typeof target;\n\n    if (type === \"string\" || type === \"boolean\" || type === \"number\" || type === \"symbol\" || type === \"undefined\" || type === \"function\") {\n      return target;\n    }\n\n    if (!userClass) {\n      userClass = target.constructor;\n    }\n\n    let injectClass = this.injectClassBinder.get(userClass);\n    this.decoratorInject(target, injectClass);\n    return target;\n  }\n\n  decoratorInject(target, injectClass) {\n    let that = this;\n    injectClass.list.forEach(binding => {\n      let injectBinding = that.binder.getBinding(binding.value, binding.name);\n\n      if (injectBinding) {\n        let instance = that.getInjectValue(injectBinding.key, injectBinding.name);\n        target[binding.property] = instance;\n      }\n    });\n  }\n\n  getInjectValue(type, name) {\n    let binding = this.binder.getBinding(type, name);\n    if (!binding) return null;\n\n    if (binding.getBindingType() === \"Value\") {\n      if (binding.isInject()) {\n        let injv = this.inject(binding.value);\n        binding.toInject(false);\n        return injv;\n      } else {\n        return binding.value;\n      }\n    } else if (binding.getBindingType() == \"Singleton\") {\n      if (binding.isValueConstructor || binding.value == null) {\n        this.instantiate(binding, true);\n      }\n\n      return binding.value;\n    } else {\n      return this.instantiate(binding, true);\n    }\n  }\n\n}","export var CommonEnum;\n\n(function (CommonEnum) {\n  CommonEnum[\"Context\"] = \"Context\";\n  CommonEnum[\"Root\"] = \"Root\";\n})(CommonEnum || (CommonEnum = {}));\n\nexport var IocError;\n\n(function (IocError) {\n  IocError.IC_ERROR = \"can't implement class that is only as interface\";\n})(IocError || (IocError = {}));\n\nexport class IConstructorName {}","var __decorate = this && this.__decorate || function (decorators, target, key, desc) {\n  var c = arguments.length,\n      r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,\n      d;\n  if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n  return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\n\nimport { inject } from \"./Injector/InjectDecorator\";\nimport { Stack } from \"./Stack\";\nimport { Prototype } from \"./Prototype\";\nexport var PoolOverflowBehavior;\n\n(function (PoolOverflowBehavior) {\n  PoolOverflowBehavior[PoolOverflowBehavior[\"EXCEPTION\"] = 0] = \"EXCEPTION\";\n  PoolOverflowBehavior[PoolOverflowBehavior[\"WARNING\"] = 1] = \"WARNING\";\n  PoolOverflowBehavior[PoolOverflowBehavior[\"IGNORE\"] = 2] = \"IGNORE\";\n})(PoolOverflowBehavior || (PoolOverflowBehavior = {}));\n\nexport var BindingConstraintType;\n\n(function (BindingConstraintType) {\n  BindingConstraintType[BindingConstraintType[\"ONE\"] = 0] = \"ONE\";\n  BindingConstraintType[BindingConstraintType[\"MANY\"] = 1] = \"MANY\";\n  BindingConstraintType[BindingConstraintType[\"POOL\"] = 2] = \"POOL\";\n})(BindingConstraintType || (BindingConstraintType = {}));\n\nexport var PoolInflationType;\n\n(function (PoolInflationType) {\n  PoolInflationType[PoolInflationType[\"INCREMENT\"] = 0] = \"INCREMENT\";\n  PoolInflationType[PoolInflationType[\"DOUBLE\"] = 1] = \"DOUBLE\";\n})(PoolInflationType || (PoolInflationType = {}));\n\nexport class NInstanceProvider {\n  get constructorName() {\n    return \"IInstanceProvider\";\n  }\n\n}\nexport class Pool {\n  constructor() {\n    this.instancesAvailable = new Stack();\n    this.instancesInUse = new Set();\n  }\n\n  Pool() {\n    this.size = 0;\n    this.constraint = BindingConstraintType.POOL;\n    this.uniqueValues = true;\n    this.overflowBehavior = PoolOverflowBehavior.EXCEPTION;\n    this.inflationType = PoolInflationType.DOUBLE;\n  }\n\n  bind(type) {\n    this.poolType = type;\n  }\n\n  add(value) {\n    this.failIf(!Prototype.isProtetype(value, this.poolType), \" Pool Type mismatch. Pools must consist of a common concrete type.\\n\\t\\tPool type: \" + this.poolType + \"\\n\\t\\tMismatch type: \" + value);\n    this._instanceCount++;\n    this.instancesAvailable.push(value);\n    return this;\n  }\n\n  addList(list) {\n    if (list && list.length > 0) {\n      list.forEach(item => {\n        this.add(item);\n      });\n    }\n\n    return this;\n  }\n\n  remove(value) {\n    this._instanceCount--;\n    this.removeInstance(value);\n    return this;\n  }\n\n  removeList(list) {\n    if (list && list.length > 0) {\n      list.forEach(item => {\n        this.remove(item);\n      });\n    }\n\n    return this;\n  }\n\n  get value() {\n    return this.getInstance();\n  }\n\n  get instanceCount() {\n    return this._instanceCount;\n  }\n\n  getInstance() {\n    if (this.instancesAvailable.size > 0) {\n      let retv = this.instancesAvailable.pop();\n      this.instancesInUse.add(retv);\n      return retv;\n    }\n\n    let instancesToCreate = 0;\n\n    if (this.size > 0) {\n      if (this.instanceCount == 0) {\n        instancesToCreate = this.size;\n      } else {\n        this.failIf(this.overflowBehavior == PoolOverflowBehavior.EXCEPTION, \"A pool has overflowed its limit.\\n\\t\\tPool type: \" + this.poolType);\n\n        if (this.overflowBehavior == PoolOverflowBehavior.WARNING) {}\n\n        return null;\n      }\n    } else {\n      if (this.instanceCount == 0 || this.inflationType == PoolInflationType.INCREMENT) {\n        instancesToCreate = 1;\n      } else {\n        instancesToCreate = this.instanceCount;\n      }\n    }\n\n    if (instancesToCreate > 0) {\n      this.failIf(this.instanceProvider == null, \"A Pool of type: \" + this.poolType + \" has no instance provider.\");\n\n      for (let a = 0; a < instancesToCreate; a++) {\n        let newInstance = this.instanceProvider.getInstance(this.poolType);\n        this.add(newInstance);\n      }\n\n      return this.getInstance();\n    }\n\n    return null;\n  }\n\n  returnInstance(value) {\n    if (this.instancesInUse.has(value)) {\n      value.restore();\n      this.instancesInUse.delete(value);\n      this.instancesAvailable.push(value);\n    }\n  }\n\n  clean() {\n    this.instancesAvailable.clear();\n    this.instancesInUse = new Set();\n    this._instanceCount = 0;\n  }\n\n  get available() {\n    return this.instancesAvailable.size;\n  }\n\n  restore() {\n    this.clean();\n    this.size = 0;\n  }\n\n  retain() {\n    this.isRetain = true;\n  }\n\n  release() {\n    this.isRetain = false;\n  }\n\n  removeInstance(value) {\n    this.failIf(value != this.poolType, \"Attempt to remove a instance from a pool that is of the wrong Type:\\n\\t\\tPool type: \" + this.poolType.toString() + \"\\n\\t\\tInstance type: \" + value.toString());\n\n    if (this.instancesInUse.has(value)) {\n      this.instancesInUse.delete(value);\n    } else {\n      this.instancesAvailable.pop();\n    }\n  }\n\n  failIf(condition, message) {\n    if (condition) {\n      throw new Error(message);\n    }\n  }\n\n}\n\n__decorate([inject(NInstanceProvider)], Pool.prototype, \"instanceProvider\", void 0);","export class Prototype {\n  static isProtetype(type, prototype) {\n    return type instanceof prototype;\n  }\n\n  static getPrototypeListByInst(target) {\n    return this.getPrototypeList(target.constructor);\n  }\n\n  static getPrototypeList(target) {\n    let that = this;\n\n    if (!this.prototypeMap.has(target)) {\n      let extendsList = [];\n      let typeList = [];\n      let proto = target.__proto__;\n      let ctor = target;\n\n      while (true) {\n        if (ctor.prototype && ctor.prototype.__proto__ !== Object.prototype) {\n          extendsList.push(proto);\n          typeList.push(ctor);\n          typeList.forEach(type => {\n            that.AddPrototype(type, proto);\n          });\n          ctor = proto;\n          proto = proto.__proto__;\n        } else {\n          break;\n        }\n      }\n    }\n\n    let values = this.prototypeMap.get(target);\n\n    if (values) {\n      return Array.from(values);\n    } else {\n      return [];\n    }\n  }\n\n  static AddPrototype(tpye, prototype) {\n    let extendSet;\n\n    if (this.prototypeMap.has(tpye)) {\n      extendSet = this.prototypeMap.get(tpye);\n    } else {\n      extendSet = new Set();\n      this.prototypeMap.set(tpye, extendSet);\n    }\n\n    extendSet.add(prototype);\n  }\n\n  static hasPrototypeList(target) {\n    if (this.prototypeMap.has(target)) {\n      return true;\n    } else {\n      return false;\n    }\n  }\n\n}\nPrototype.prototypeMap = new Map();","export class NSignal {\n  get constructorName() {\n    return \"ISignal\";\n  }\n\n}\nexport class Signal {\n  constructor() {\n    this._listener = [];\n    this._onceListener = [];\n  }\n\n  dispatch(...args) {\n    let that = this;\n    let ret;\n    let retOne;\n    let results = null;\n\n    if (that._listener && that._listener.length != 0) {\n      this._listener.forEach(function (action) {\n        ret = action(that, ...args);\n\n        if (ret !== null) {\n          results = [];\n\n          if (Array.isArray(ret)) {\n            results.push(...ret);\n          } else {\n            results.push(ret);\n          }\n        }\n      });\n    }\n\n    if (that._onceListener && that._onceListener.length != 0) this._listener.forEach(function (action) {\n      retOne = action(that, ...args);\n\n      if (retOne !== null) {\n        if (!results) results = [];\n\n        if (Array.isArray(retOne)) {\n          results.push(...retOne);\n        } else {\n          results.push(retOne);\n        }\n      }\n    });\n    this._onceListener.length = 0;\n    return results;\n  }\n\n  dispatchSole(...args) {\n    let that = this;\n    let result = null;\n\n    if (that._listener && that._listener.length != 0) {\n      this._listener.forEach(function (action) {\n        result = action(that, ...args);\n      });\n    }\n\n    if (that._onceListener && that._onceListener.length != 0) this._listener.forEach(function (action) {\n      result = action(that, ...args);\n    });\n    this._onceListener.length = 0;\n\n    if (result.length != 0) {\n      return result[0];\n    } else {\n      return null;\n    }\n  }\n\n  dispatchAsync(...args) {\n    let that = this;\n    let result;\n    let p = [];\n\n    if (that._listener && that._listener.length != 0) {\n      that._listener.forEach(function (action) {\n        result = action(that, ...args);\n        if (result) p.push(...result);\n      });\n    }\n\n    if (that._onceListener && that._onceListener.length != 0) that._listener.forEach(function (action) {\n      result = action(that, ...args);\n      if (result) p.push(...result);\n    });\n    this._onceListener.length = 0;\n    return Promise.all(p);\n  }\n\n  addListener(callback) {\n    this._listener = this.addUnique(this._listener, callback);\n  }\n\n  addOnceListener(callback) {\n    this._onceListener = this.addUnique(this._onceListener, callback);\n  }\n\n  removeAllListeners() {\n    this._listener.length = 0;\n    this._onceListener.length = 0;\n  }\n\n  addUnique(listeners, callback) {\n    if (listeners) {\n      let isUnique = false;\n\n      for (let i = 0; i < listeners.length; i++) {\n        if (listeners[i] === callback) {\n          isUnique = true;\n          break;\n        }\n      }\n\n      if (!isUnique) {\n        listeners.push(callback);\n      }\n    }\n\n    return listeners;\n  }\n\n  getTypes() {\n    let retv = [];\n    return retv;\n  }\n\n}","import { Signal } from \"./Signal\";\nexport class NSignalManager {\n  get constructorName() {\n    return \"ISignalManager\";\n  }\n\n}\nexport class SignalManager {\n  constructor() {\n    this._signal_dic = new Map();\n    this.info = \"this is a signal manager\";\n  }\n\n  finish(symbol) {}\n\n  get(symbol) {\n    if (this._signal_dic.has(symbol)) {\n      return this._signal_dic.get(symbol);\n    } else {\n      let _signal = new Signal();\n\n      if (typeof symbol == \"string\") _signal.symbol = symbol;\n\n      this._signal_dic.set(symbol, _signal);\n\n      return _signal;\n    }\n  }\n\n  delete(symbol) {\n    if (this._signal_dic.has(symbol)) {\n      return this._signal_dic.delete(symbol);\n    }\n  }\n\n}","export class Item {\n  constructor(value, next = null) {\n    this._value = value;\n    this._next = next;\n  }\n\n  set value(value) {\n    this._value = value;\n  }\n\n  get value() {\n    return this._value;\n  }\n\n  set next(next) {\n    this._next = next;\n  }\n\n  get next() {\n    return this._next;\n  }\n\n}\nexport class Stack {\n  constructor() {\n    this._size = 0;\n    this._header = new Item(null);\n  }\n\n  top() {\n    if (this._size === 0) {\n      return null;\n    }\n\n    return this._header.next.value;\n  }\n\n  push(item) {\n    let newItem = new Item(item);\n    newItem.next = this._header.next;\n    this._header.next = newItem;\n    this._size++;\n  }\n\n  pop() {\n    if (this._size === 0) {\n      return null;\n    }\n\n    let item = this._header.next;\n    this._header.next = item.next;\n    this._size--;\n    item.next = null;\n    return item.value;\n  }\n\n  clear() {\n    let item;\n    let tmp = this._header;\n\n    while (this._size !== 0) {\n      item = tmp.next;\n      tmp = item;\n      item.next = null;\n      this._size--;\n    }\n\n    this._header = null;\n  }\n\n  get isEmpty() {\n    return this._size === 0;\n  }\n\n  get size() {\n    return this._size;\n  }\n\n}","import { Stack } from \"./Stack\";\nimport { IConstructorName, CommonEnum } from \"./IocConst\";\nimport { Binder } from \"./Bind/Binder\";\nimport { Binding } from \"./Bind/Binding\";\nimport { BindingConst } from \"./Bind/BindConst\";\nimport { Prototype } from \"./Prototype\";\nimport { DecoratorClassBinder } from \"./Decorator/DecoratorClassBinder\";\nimport { DecoratorClassBinding } from \"./Decorator/DecoratorClassBinding\";\nimport { InjectFactory } from \"./Injector/InjectFactory\";\nimport { DecoratorConst } from \"./Decorator/DecoratorConst\";\nimport { Injector } from \"./Injector/Injector\";\nimport { InjectBinding } from \"./Injector/InjectBinding\";\nimport { InjectBinder, NInjectBinder } from \"./Injector/InjectBinder\";\nimport { inject } from \"./Injector/InjectDecorator\";\nimport { Pool } from \"./Pool\";\nimport { CommandBinding } from \"./Command/CommandBinding\";\nimport { CommandBinder, SignalCommandBinder } from \"./Command/CommandBinder\";\nimport { Command } from \"./Command/Command\";\nimport { Context } from \"./Context/Context\";\nimport { NCommandBinder } from \"./Command/ICommandBinder\";\nimport { CommandConst } from \"./Command/CommandConst\";\nimport { SignalManager, NSignalManager } from \"./Signal/SignalManager\";\nimport { NRoot } from \"./Context/IRoot\";\nexport { BindingConst, IConstructorName, CommonEnum, Stack, Prototype, Binding, Binder, DecoratorClassBinding, DecoratorClassBinder, DecoratorConst, InjectFactory, Injector, InjectBinding, InjectBinder, inject, Pool, CommandConst, CommandBinding, CommandBinder, Command, SignalCommandBinder, SignalManager, NSignalManager, NCommandBinder, NInjectBinder, NRoot, Context };"],"mappings":";;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;AClFA;AAAA;AAAA;AACA;AACA;AACA;AACA;;;;;;;;ACJA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;ACzGA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;AC5EA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;AC/DA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;ACxTA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;AC1BA;AAAA;AAAA;AACA;AACA;AACA;AACA;;;;;;;;ACJA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;;;;;;;;ACLA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;ACpGA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;;;;;;;;ACLA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;ACTA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;AC7IA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;ACpBA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;;;;;;;;ACLA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;ACzEA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;AC9EA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;ACnCA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;AC5EA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;ACjIA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;ACbA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;AC7LA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;AChEA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;AClIA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;ACnCA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;AC9EA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;A","sourceRoot":""}